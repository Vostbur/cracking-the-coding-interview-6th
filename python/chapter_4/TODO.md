4.7.
====

Имеется список проектов и список зависимостей (список пар проектов, для
которых первый проект зависит от второго проекта). Проект может быть
построен только после построения всех его зависимостей. Найдите такой
порядок построения, который позволит построить все проекты. Если действительного порядка не существует, верните признак ошибки.
Пример:
Ввод:
 проекты: a, b, c, d, e, f
 зависимости: (d, a), (b, f), (d, b), (a, f), (c, d)
Вывод:
 f, e, a, b, d, c

Подсказки:
----------

Постройте направленный граф, представляющий зависимости. Каждый узел
представляет проект, и ребро из A в B существует в том случае, если B зависит от A (проект A должен быть построен до B). Также можно построить
дерево наоборот, если вам так будет удобнее

Взгляните на граф. Сможете ли вы найти на нем узел, который можно заведомо безопасно построить первым?

Если вам удастся найти узел, не имеющий входящих ребер, он определенно может быть построен. Найдите такой узел (их может быть несколько)
и включите его в порядок построения. Что это будет означать для его исходящих ребер?

Когда вы решаете построить узел, его исходящее ребро может быть удалено. Как после этого найти другие узлы, которые можно построить?

Попробуйте применить совершенно иной подход: поиск в глубину от произвольного узла. Как связаны между собой поиск в глубину и допустимый порядок построения проектов?

Выберите произвольный узел и проведите от него поиск в глубину. Добравшись до конца пути, мы знаем, что этот узел может быть последним, потому
что никакие другие узлы от него не зависят. Что это значит для узлов, непосредственно предшествующих ему?

4.11.
=====

Вы пишете с нуля класс бинарного дерева поиска, который помимо методов
вставки, поиска и удаления содержит метод getRandomNode() для получения
случайного узла дерева. Вероятность выбора всех узлов должна быть одинаковой. Разработайте и реализуйте алгоритм getRandomNode; объясните, как
вы реализуете остальные методы.

Подсказки:
----------

Будьте очень внимательны. Следите за тем, чтобы все узлы выбирались
с равной вероятностью, а ваше решение не замедляло работу стандартных
алгоритмов бинарных деревьев поиска (insert, find и delete). Также
помните, что даже если дерево является сбалансированным бинарным деревом поиска, это не означает его полноты/законченности/идеальности

Вы сами создаете класс бинарного дерева поиска, поэтому можете включить
в него любую информацию о структуре дерева или узлах (если только это не
приведет к нежелательным последствиям — например, замедлению insert).
Вероятно, интервьюер именно поэтому указал, что класс пишется с нуля,
а для эффективной реализации операции потребуется сохранить дополнительную информацию

Можно ли воспользоваться алгоритмом обхода дерева для реализации этого
алгоритма (как наивное решение методом «грубой силы»)? За какое время
он будет выполняться?

Другое возможное решение — выбрать случайную глубину для обхода и выполнить случайный обход, остановившись при достижении выбранной глубины. Однако поразмыслите над этим решением. Будет ли оно работать?

Выбор случайной глубины особой пользы не принесет. Во-первых, на нижних уровнях больше узлов, чем на верхних. Во-вторых, даже если бы эти
вероятности удалось сбалансировать, возможен «тупик», когда необходимо
выбрать узел на глубине 5, а на глубине 3 обнаруживается лист. Впрочем,
идея балансировки вероятностей выглядит интересно

Многие кандидаты предлагают наивное решение: выбрать случайное число
от 1 до 3. Если выбрано число 1, то возвращается текущий узел; если 2 —
происходит переход к левому поддереву, а если 3 — происходит переход
к правому поддереву. Такое решение не работает. Почему? Можно ли исправить его так, чтобы оно заработало?

Предыдущее решение (с выбором случайного числа от 1 до 3) не работает
из-за того, что вероятности узлов не равны. Например, корень будет возвращаться с вероятностью 1/3, даже если дерево содержит более 50 узлов.
Очевидно, все узлы не могут иметь вероятность 1/3. Проблему можно решить выбором случайного числа от 1 до размера дерева. Впрочем, проблема
будет решена только для корня. А как насчет остальных узлов?

Проблема предыдущего решения заключается в том, что на одной стороне
поддерева может быть больше узлов, чем на другой. Следовательно, необходимо взвесить вероятности выбора левого или правого поддерева в зависимости от количества узлов с каждой из сторон. Как будет работать такое
решение? Как узнать количество узлов?

4.12.
=====

Дано бинарное дерево, в котором каждый узел содержит целое число (положительное или отрицательное). Разработайте алгоритм для подсчета всех
путей, сумма значений которых соответствует заданной величине. Обратите
внимание, что путь не обязан начинаться или заканчиваться в корневом или
листовом узле, но он должен идти вниз (переходя только от родительских
узлов к дочерним).

Подсказки:
----------

Попробуйте упростить задачу. Что если путь должен начинаться от корня?

Не забудьте, что пути могут перекрываться. Например, при поиске суммы 6
действителен как путь 1->3->2, так и путь 1->3->2->4->-6->2

Если каждый путь должен начинаться от корня, мы можем обойти все возможные пути, начиная от корня. Сумма отслеживается в процессе обхода,
а счетчик totalPaths увеличивается при каждом нахождении пути с целевой суммой. Как распространить ситуацию на пути, который может начинаться с произвольного узла? Не забудьте: для начала стоит создать решение, работающее методом «грубой силы». Оптимизацией можно заняться
позднее

Чтобы обобщить решение для путей с произвольным началом, достаточно
повторить процесс для всех узлов

Если вы спроектировали алгоритм так, как описано выше, он выполняется
за время O(N log N) в сбалансированном дереве. Это объясняется тем, что
он содержит N узлов, каждый из которых в худшем случае находится на
глубине O(log N). Узел обрабатывается один раз для каждого узла, расположенного выше него. Следовательно, N узлов будут обработаны O(log N) раз.
Существует оптимизация, которая обеспечит время выполнения O(N)

Какая работа дублируется в текущем алгоритме «грубой силы»?

Рассмотрите каждый путь, начинающийся от корня (существуют N таких путей), как массив. По сути наш алгоритм «грубой силы» берет каждый массив
и ищет в нем все смежные подпоследовательности, имеющие заданную сумму. Для этого мы вычисляем все подмассивы и их суммы. Возможно, стоит
сосредоточиться на этой подзадаче. Как для заданного массива найти все
смежные подпоследовательности с конкретной суммой? Еще раз поразмыслите над повторением работы в алгоритме «грубой силы»

Мы ищем подмассивы с суммой targetSum. Заметим, что значение runningSumi
 (сумма элементов от 0 до i) может быть получено за постоянное
время. Чтобы подмассив элементов от i до j имел сумму targetSum, значение runningSumi-1 + targetSum должно быть равно runningSumj
 (попробуйте нарисовать элементы массива или цепочку чисел). Так как мы можем
отслеживать runningSum «на ходу», как быстро найти количество индексов
i, для которых выполняется это уравнение?

Попробуйте использовать хеш-таблицу, связывающую значение runningSum
с количеством элементов, обладающих этим значением runningSum

После того как вы проработаете алгоритм для поиска в массиве всех смежных подмассивов с заданной суммой, попробуйте применить его к дереву.
Помните, что в процессе обхода и модификации хеш-таблицы может возникнуть необходимость в «восстановлении» ее содержимого при возврате
